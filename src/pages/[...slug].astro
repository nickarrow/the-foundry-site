---
import Layout from '../layouts/Layout.astro';
import Sidebar from '../components/Sidebar.astro';
import Breadcrumbs from '../components/Breadcrumbs.astro';
import MobileHeader from '../components/MobileHeader.astro';
import { getAllContentFiles, getContentFile } from '../lib/content';
import { processMarkdown } from '../lib/markdown';
import {
  getCharacterAssets,
  convertDataswornLinks,
  type CharacterAsset,
  type MergedAsset,
} from '../lib/datasworn-assets';

export async function getStaticPaths() {
  const files = getAllContentFiles();

  return files.map((file) => ({
    params: { slug: file.slug || undefined },
    props: { file },
  }));
}

const { slug } = Astro.params;
const allFiles = getAllContentFiles();

// Handle homepage
const actualSlug = slug || 'welcome-to-ironverse';
const fileData = getContentFile(actualSlug);

if (!fileData) {
  return Astro.redirect('/404');
}

const { frontmatter, content, title } = fileData;
let htmlContent = await processMarkdown(content, allFiles);

// Determine content type from frontmatter
const ironVaultKind = frontmatter['iron-vault-kind'];
const isCharacter = ironVaultKind === 'character';
const isProgressTrack = ironVaultKind === 'progress';

// Generate character meters HTML and replace placeholder
if (isCharacter) {
  const characterName = frontmatter.name || title;
  const xpSpent = frontmatter.xp_spent || 0;
  const xpAdded = frontmatter.xp_added || 0;

  const stats = [
    { name: 'edge', value: frontmatter.edge || 0 },
    { name: 'heart', value: frontmatter.heart || 0 },
    { name: 'iron', value: frontmatter.iron || 0 },
    { name: 'shadow', value: frontmatter.shadow || 0 },
    { name: 'wits', value: frontmatter.wits || 0 },
  ];

  const meters = [
    { name: 'health', value: frontmatter.health || 5 },
    { name: 'spirit', value: frontmatter.spirit || 5 },
    { name: 'supply', value: frontmatter.supply || 5 },
  ];

  const momentum = frontmatter.momentum || 0;

  // Special tracks (legacy tracks)
  const specialTracks = [
    {
      name: 'Quests',
      progress: frontmatter.Quests_Progress || 0,
      xp: frontmatter.Quests_XPEarned || 0,
    },
    {
      name: 'Bonds',
      progress: frontmatter.Bonds_Progress || 0,
      xp: frontmatter.Bonds_XPEarned || 0,
    },
    {
      name: 'Discoveries',
      progress: frontmatter.Discoveries_Progress || 0,
      xp: frontmatter.Discoveries_XPEarned || 0,
    },
  ];

  // Calculate XP from tracks
  const xpFromTracks =
    (frontmatter.Quests_XPEarned || 0) +
    (frontmatter.Bonds_XPEarned || 0) +
    (frontmatter.Discoveries_XPEarned || 0);
  const totalXp = xpFromTracks + xpAdded;

  // Character info fields from frontmatter
  const callsign = frontmatter.callsign || '';
  const pronouns = frontmatter.pronouns || '';
  const description = frontmatter.description || '';
  const player = frontmatter.player || '';

  // Character Info HTML - matches the CSS grid layout
  const characterInfoHtml = `
    <section class="iron-vault-character">
      <section class="character-info">
        <div class="name"><input type="text" value="${characterName}" readonly /></div>
        <dl>
          <dt>Callsign</dt>
          <dd class="callsign"><input type="text" value="${callsign}" readonly /></dd>
          <dt>Pronouns</dt>
          <dd class="pronouns"><input type="text" value="${pronouns}" readonly /></dd>
          <dt>Description</dt>
          <dd class="description"><input type="text" value="${description}" readonly /></dd>
          <dt>Player</dt>
          <dd class="player"><input type="text" value="${player}" readonly /></dd>
          <dt>XP From Tracks</dt>
          <dd class="xp-from-tracks">${xpFromTracks}</dd>
          <dt>XP Added</dt>
          <dd class="xp-added">${xpAdded}</dd>
          <dt>Total XP Earned</dt>
          <dd class="total-xp">${totalXp}</dd>
          <dt>XP Spent</dt>
          <dd class="xp-spent">${xpSpent}</dd>
        </dl>
      </section>
    </section>
  `;

  htmlContent = htmlContent.replace(
    '<div class="iron-vault-character-info-placeholder"></div>',
    characterInfoHtml
  );

  // Stats HTML
  const statsHtml = stats
    .map(
      (s) => `
    <li>
      <dl>
        <dt data-value="${s.name}">${s.name}</dt>
        <dd><input type="text" inputmode="numeric" value="${s.value}" readonly /></dd>
      </dl>
    </li>
  `
    )
    .join('');

  const characterStatsHtml = `
    <section class="iron-vault-character">
      <ul class="stats">${statsHtml}</ul>
    </section>
  `;

  htmlContent = htmlContent.replace(
    '<div class="iron-vault-character-stats-placeholder"></div>',
    characterStatsHtml
  );

  // Meters HTML
  const metersHtml = meters
    .map(
      (m) => `
    <li>
      <dl>
        <dt data-value="${m.name}">${m.name}</dt>
        <dd data-value="${m.value}"><span>${m.value}</span></dd>
      </dl>
    </li>
  `
    )
    .join('');

  const characterMetersHtml = `
    <section class="iron-vault-character">
      <ul class="meters">
        ${metersHtml}
        <li class="momentum">
          <dl>
            <dt>momentum</dt>
            <dd data-value="${momentum}"><span>${momentum}</span></dd>
          </dl>
        </li>
      </ul>
    </section>
  `;

  htmlContent = htmlContent.replace(
    '<div class="iron-vault-character-meters-placeholder"></div>',
    characterMetersHtml
  );

  // Special Tracks HTML (legacy tracks with progress boxes)
  const getBoxValue = (ticks: number, boxIndex: number): number => {
    const fullBoxes = Math.floor(ticks / 4);
    const remainingTicks = ticks % 4;
    if (boxIndex < fullBoxes) return 4;
    if (boxIndex === fullBoxes) return remainingTicks;
    return 0;
  };

  const specialTracksHtml = specialTracks
    .map((track) => {
      const boxesHtml = Array.from(
        { length: 10 },
        (_, i) => `<li data-value="${getBoxValue(track.progress, i)}"></li>`
      ).join('');

      return `
      <div class="iron-vault-track" data-track="${track.name.toLowerCase()}">
        <span class="track-name">${track.name}</span>
        <span class="track-xp">${track.xp}</span>
        <div class="track-widget">
          <ol>${boxesHtml}</ol>
        </div>
      </div>
    `;
    })
    .join('');

  const characterSpecialTracksHtml = `
    <section class="iron-vault-character">
      <ul class="special-tracks">
        ${specialTracksHtml}
      </ul>
    </section>
  `;

  htmlContent = htmlContent.replace(
    '<div class="iron-vault-character-special-tracks-placeholder"></div>',
    characterSpecialTracksHtml
  );

  // Impacts HTML - read from frontmatter
  const impacts = {
    // Misfortunes
    wounded: frontmatter.wounded || false,
    shaken: frontmatter.shaken || false,
    unprepared: frontmatter.unprepared || false,
    // Lasting Effects
    permanently_harmed: frontmatter.permanently_harmed || false,
    traumatized: frontmatter.traumatized || false,
    // Burdens
    doomed: frontmatter.doomed || false,
    tormented: frontmatter.tormented || false,
    indebted: frontmatter.indebted || false,
    // Vehicle
    battered: frontmatter.battered || false,
    cursed: frontmatter.cursed || false,
  };

  const checkedAttr = (val: boolean) => (val ? 'checked' : '');

  const characterImpactsHtml = `
    <section class="iron-vault-character">
      <ul class="impact-categories">
        <li>
          <header>Misfortunes</header>
          <ul>
            <li><label><input type="checkbox" ${checkedAttr(impacts.wounded)} disabled /><span>Wounded</span></label></li>
            <li><label><input type="checkbox" ${checkedAttr(impacts.shaken)} disabled /><span>Shaken</span></label></li>
            <li><label><input type="checkbox" ${checkedAttr(impacts.unprepared)} disabled /><span>Unprepared</span></label></li>
          </ul>
        </li>
        <li>
          <header>Lasting Effects</header>
          <ul>
            <li><label><input type="checkbox" ${checkedAttr(impacts.permanently_harmed)} disabled /><span>Permanently Harmed</span></label></li>
            <li><label><input type="checkbox" ${checkedAttr(impacts.traumatized)} disabled /><span>Traumatized</span></label></li>
          </ul>
        </li>
        <li>
          <header>Burdens</header>
          <ul>
            <li><label><input type="checkbox" ${checkedAttr(impacts.doomed)} disabled /><span>Doomed</span></label></li>
            <li><label><input type="checkbox" ${checkedAttr(impacts.tormented)} disabled /><span>Tormented</span></label></li>
            <li><label><input type="checkbox" ${checkedAttr(impacts.indebted)} disabled /><span>Indebted</span></label></li>
          </ul>
        </li>
        <li>
          <header>Current Vehicle</header>
          <ul>
            <li><label><input type="checkbox" ${checkedAttr(impacts.battered)} disabled /><span>Battered</span></label></li>
            <li><label><input type="checkbox" ${checkedAttr(impacts.cursed)} disabled /><span>Cursed</span></label></li>
          </ul>
        </li>
      </ul>
    </section>
  `;

  htmlContent = htmlContent.replace(
    '<div class="iron-vault-character-impacts-placeholder"></div>',
    characterImpactsHtml
  );

  // Assets HTML - render full asset cards from Datasworn data
  const characterAssetData: CharacterAsset[] = frontmatter.assets || [];
  const mergedAssets = getCharacterAssets(characterAssetData);

  const renderAssetCard = (merged: MergedAsset): string => {
    const { definition, state } = merged;

    // Get custom name from options if available (unused but kept for future use)
    // const customName = state.options?.name || '';

    // Render abilities with enabled state from character
    const abilitiesHtml = definition.abilities
      .map((ability, index) => {
        const isEnabled = state.abilities[index] || false;
        const abilityText = convertDataswornLinks(ability.text);
        return `
        <li>
          <label>
            <input type="checkbox" ${isEnabled ? 'checked' : ''} disabled />
            <span class="markdown-wrapper">${abilityText}</span>
          </label>
        </li>
      `;
      })
      .join('');

    // Render options (like custom name)
    let optionsHtml = '';
    if (definition.options && Object.keys(definition.options).length > 0) {
      const optionItems = Object.entries(definition.options)
        .map(([key, opt]) => {
          const value = state.options?.[key] || '';
          return `
          <li>
            <label>
              <span>${opt.label?.toUpperCase() || key.toUpperCase()}</span>
              <input type="text" value="${value}" readonly />
            </label>
          </li>
        `;
        })
        .join('');
      optionsHtml = `<div class="options"><ul>${optionItems}</ul></div>`;
    }

    // Render controls (like integrity, health, command)
    let controlsHtml = '';
    if (definition.controls && Object.keys(definition.controls).length > 0) {
      const controlItems = Object.entries(definition.controls)
        .map(([key, ctrl]) => {
          // Skip nested controls (like battered/cursed which are under integrity)
          if (key.includes('/')) return '';

          const currentValue = state.controls?.[key] ?? ctrl.value;

          if (ctrl.field_type === 'condition_meter') {
            // Render as a meter with buttons
            const max = ctrl.max || 5;
            const min = ctrl.min || 0;
            const meterItems = Array.from({ length: max - min + 1 }, (_, i) => {
              const val = min + i;
              const isSelected = val === currentValue;
              return `<li${isSelected ? ' class="selected"' : ''}><label><span>${val}</span></label></li>`;
            }).join('');

            // Check for nested impact controls (battered, cursed, etc.)
            let impactControls = '';
            if (ctrl.controls) {
              const impactItems = Object.entries(ctrl.controls)
                .map(([impactKey, impactCtrl]: [string, { label?: string }]) => {
                  const impactValue = state.controls?.[`${key}/${impactKey}`] || false;
                  const label = impactCtrl.label || impactKey;
                  return `<span class="impact-control"><label><input type="checkbox" ${impactValue ? 'checked' : ''} disabled /><span>${label.toUpperCase()}</span></label></span>`;
                })
                .join(' ');
              impactControls = `<div class="meter-impacts">${impactItems}</div>`;
            }

            return `
            <li class="condition-meter">
              ${impactControls}
              <span class="meter-label">${ctrl.label?.toUpperCase() || key.toUpperCase()}</span>
              <ul class="meter">${meterItems}</ul>
            </li>
          `;
          } else if (ctrl.field_type === 'checkbox') {
            const isChecked = state.controls?.[key] || false;
            return `
            <li>
              <label>
                <input type="checkbox" ${isChecked ? 'checked' : ''} disabled />
                <span>${ctrl.label?.toUpperCase() || key.toUpperCase()}</span>
              </label>
            </li>
          `;
          }
          return '';
        })
        .filter(Boolean)
        .join('');

      if (controlItems) {
        controlsHtml = `<ul class="controls">${controlItems}</ul>`;
      }
    }

    const sourceTitle = definition._source?.title || 'Ironsworn';

    return `
      <article class="iron-vault-asset-card">
        <header>
          <dl>
            <dt>Category</dt>
            <dd class="category">${definition.category}</dd>
            <dt>Name</dt>
            <dd class="name">${definition.name}</dd>
          </dl>
        </header>
        ${optionsHtml}
        <ul class="abilities">
          ${abilitiesHtml}
        </ul>
        ${controlsHtml}
        <footer>${sourceTitle}</footer>
      </article>
    `;
  };

  const assetCardsHtml = mergedAssets.map(renderAssetCard).join('');

  const characterAssetsHtml = `
    <section class="iron-vault-character assets">
      <ul>
        ${assetCardsHtml ? assetCardsHtml : '<li><em>No assets</em></li>'}
      </ul>
    </section>
  `;

  htmlContent = htmlContent.replace(
    '<div class="iron-vault-character-assets-placeholder"></div>',
    characterAssetsHtml
  );
}

// Progress track data
const trackData = isProgressTrack
  ? {
      name: frontmatter.name || title,
      rank: frontmatter.rank || 'dangerous',
      progress: frontmatter.progress || 0,
      trackType: frontmatter['track-type'] || 'Vow',
      complete: frontmatter.tags?.includes('complete') || false,
    }
  : null;

// Generate progress track HTML and replace placeholder
if (isProgressTrack && trackData) {
  const ticks = trackData.progress;
  const fullBoxes = Math.floor(ticks / 4);
  const remainingTicks = ticks % 4;

  const getBoxValue = (boxIndex: number): number => {
    if (boxIndex < fullBoxes) return 4;
    if (boxIndex === fullBoxes) return remainingTicks;
    return 0;
  };

  const displayRank =
    trackData.rank.charAt(0).toUpperCase() + trackData.rank.slice(1).toLowerCase();

  const boxesHtml = Array.from(
    { length: 10 },
    (_, i) => `<li data-value="${getBoxValue(i)}">${getBoxValue(i)}</li>`
  ).join('');

  const trackHtml = `
    <div class="iron-vault-track" data-rank="${trackData.rank}" data-complete="${trackData.complete}">
      <span class="track-type">${trackData.trackType.toUpperCase()}</span>
      <span class="track-rank">${displayRank.toUpperCase()}</span>
      <div class="track-name">${trackData.name}</div>
      <div class="track-widget">
        <ol>${boxesHtml}</ol>
      </div>
      <div class="track-progress">${fullBoxes}/10 (${ticks} ticks)</div>
    </div>
  `;

  htmlContent = htmlContent.replace('<div class="iron-vault-track-placeholder"></div>', trackHtml);
}
---

<Layout title={title}>
  <MobileHeader slug={actualSlug} />
  <Sidebar />

  <main class="content">
    <Breadcrumbs slug={actualSlug} />

    <article class="page">
      <div class="prose" set:html={htmlContent} />
    </article>
  </main>
</Layout>
